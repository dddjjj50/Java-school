■クラス　機械でいうｒと部品の設計図
└オブジェクト
　└フィールド
　└コンストラクター：インスタンス化されたときに最初に呼び出される処理。書式は「修飾子 コンストラクター名（データ型 引数名）｛｝」
　└メソッド

■メソッドの書式 →　修飾子 戻り値の型 メソッド名（データ型 引数名, データ型 引数名,,,）｛｝
・修飾子：アクセスできる範囲を指定

■修飾子
強 private(同一クラスからのみアクセス可)
↑  default(privateのアクセス範囲と同一パッケージにあるクラスからアクセス可能)
↓  protected(defaultのアクセス範囲とサブクラスからアクセス可能)
弱 public(すべてのクラスからアクセス可)

■カプセル化…フィールドを外部から直接アクセスできなくする。



■クラス図
抽象クラスならクラス名が斜体になる
＜＜インターフェース＞＞

■継承　あるクラスをもとに新しいクラスを作ること。
元のクラスの機能（フィールドやメソッド）を受け継ぐことができて、
さらに新しい機能（フィールドやメソッド）を追加することができる。これを拡張。

・スーパークラス：元、親のクラス
・サブクラス：親の機能を継承して新たにつくられた子クラス。
サブクラスが継承できるのはひとつのスーパークラスだけ。（単一継承）
「このスーパークラスのこの部分と、別のスーパークラスのこの部分を継承」という多重継承は不可

■パッケージ　別にひとつのアプリでひとつのパッケージじゃない。

----------------------
料理で例える（アラビアータ）
-----------------
■クラスの中にフィールド、コンストラクタ、メソッドがある。
・フィールド　レシピの材料（パスタ、トマト缶、唐辛子…）
・コンストラクタ　下ごしらえ
        （なにを下ごしらえとするかはプログラマーによって違う、フィールドの段階で整えてある場合もあり）
・メソッド　料理の手順（火にかける、混ぜる、味付けのタイミング）
■オブジェクト≒インスタンス（レシピを使って実際に作った料理）
■インスタンス化　　実際に料理をすること。
    arabia_ta todeysDinner = new arabia_ta();
■オーバーロード　同一クラスないにメソッドを複数用意して、少し違うアラビアータを作る（辛さ、具材等）
■アクセス修飾子　レシピの公開範囲

■staticフィールド、staticメソッド
✔ static あり → クラス変数として扱い、クラス名.変数名 でアクセス！
✔ static なし → インスタンス変数なので、オブジェクト.変数名 でアクセス！
✔ static の有無で「変数が共有されるかどうか」が変わる！
フィールドやメソッドにstaticがついていれば、インスタンス生成しなくてもほかのクラスでそのフィールドを使える。
ただし、「そのフィールドがあるクラス名．フィールド名」というふうにもともとのクラスを明記する必要がある。

■継承
クラス名のあとに「extends 継承元のクラス名」をつける。
「スーパークラス」継承元のクラス
「サブクラス」継承先のクラス

■オーバーロードとオーバーライド
・オーバーロード：同じ名前のメソッドでも、引数が違うと微妙にやることが違うってときに使う。
・オーバーライド：スーパークラスのメソッドをサブクラスで上書きすること。

■コンストラクター
・インスタンス化されたときに最初に呼び出される処理。
・書式は「修飾子 コンストラクター名（データ型 引数名）｛｝」
・コンストラクター名はクラス名と同じ。
・戻り値を持てない
・特別な場合を除いて、クラスのアクセス修飾子と同じにしておく。
・呼び出すときは「new コンストラクター名（）」インスタンス生成と同じ
・メソッドと同じようにオーバーロードできる。

■thisステートメント
わかりやすく印をつけておくようなイメージ。
そのクラスでしかつかえない。
例えばString name;って変数宣言をしたら、
this.name=name;で印をつけられる。

■カプセル化
フィールドにprivateをつけると、ほかのクラスでフィールドの値を変更できなくなる

■instanceof演算子
「a instanceof クラス名」
型変換が可能ならtrue、不可能ならfalseが返る。



